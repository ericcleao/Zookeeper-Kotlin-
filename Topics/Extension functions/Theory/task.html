<div class="step-text">
<p>Often a developer doesn't write everything from scratch but uses already written code. It saves them some time. However, there are some downsides such as the inability to edit the used code, especially when the code comes from another developer. Let's look how to optimize your work!</p>
<h5 id="problem-with-existing-classes">Problem with existing classes</h5>
<p>To work with classes that you can't modify, you can write a function that takes an object of that class as an argument:</p>
<pre><code class="language-kotlin">fun repeated(string: String): String = string + string

repeated("ha")  // returns "haha"</code></pre>
<p>Do you see an issue here? In Kotlin, standard operations are available as <a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, a member function is a function that is declared within a class and implements a common behavior for a set of objects that belong to the same class. | It is called a member function because it works with a specific object of a class and can access its fields. The keyword 'this' represents the current instance of the class and is used to call the member function.">member functions</a>. For example, to get the first symbol of the <code class="language-kotlin">"ha"</code> string, you can write <code class="language-kotlin">"ha".first()</code>. It's more convenient to use a single <a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, a syntax refers to the set of rules and conventions that dictate how a program should be written in the language. | It includes the structure of statements, expressions, and keywords, as well as the use of indentation, whitespace, and comments. An expression, for example, is a type of syntax that evaluates to a single value, such as a literal value, variable, function call, or a combination of these elements using operators. Understanding the syntax of Kotlin is essential for writing clear, maintainable, and error-free code.">syntax</a> for all operations. So how can we add a member function to the uneditable <code class="language-kotlin">String</code> class?</p>
<h5 id="defining-and-calling-extension-functions">Defining and calling extension functions</h5>
<p>Kotlin has just the right <strong>syntactic sugar</strong> for it: <a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, an extension function is a function that can be called on an existing class as if it were a member of that class, but is actually defined outside of the class. | It allows developers to add new functionality to existing classes without modifying the original class code. Extension functions take the receiver object (the class they are extending) as the first argument, which is implicitly passed. They can take arguments and return values like regular functions. If a class has both a member function and an extension function with the same name and signature, the member function will take precedence.">extension functions</a>. Let's rewrite the <code class="language-kotlin">repeated</code> function as an extension one:</p>
<pre><code class="language-kotlin">fun String.repeated(): String = this + this</code></pre>
<p>Now to get the <code class="language-kotlin">"haha"</code> we can write</p>
<pre><code class="language-kotlin">"ha".repeated()</code></pre>
<p>As you can see, the syntax to define an extension function is like defining a simple function. Just write the <strong>name of</strong> a <strong>class</strong> that you would like to extend <strong>and</strong> add a <strong>dot</strong> <u>before</u> the function name. The class to be extended is called a <strong><a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, a receiver type is a special parameter of a lambda function that gives it the ability to access the members (properties and methods) of the corresponding receiver object directly, without any qualifier. | It is specified before the dot in the notation, for example, `Integer. () -&gt; Unit` represents a function type that can be called on an integer receiver object. A lambda with a receiver is similar to an extension function, and it allows you to define behavior for a specific object or class.">receiver type</a></strong>.</p>
<p>You can get access to the field of an object in the extension function almost as easily, as in the member function. That object is called a <strong><a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, a receiver object is an object instance that extends its functionality by the function. | It can be implicit or explicit, and it's the object on which the extension function is invoked. When using a lambda with a receiver, you can give one of the parameters of the lambda a special status of a receiver, which allows you to refer to its members directly without any qualifier. This way, you can indicate how methods are resolved in the lambda body and enable access to the visible methods and properties of the receiver of the lambda in its body without any additional qualifier.">receiver object</a></strong>.</p>
<pre><code class="language-kotlin">class Client(val name: String, val age: Int)

fun Client.getInfo() = "$name $age" // Client is the receiver type


val client = Client("John", 32)
print(client.getInfo()) // client is the receiver object
</code></pre>
<p>Note, if the developer hides some information (you will know how to do it later) and your code cannot get it, the extension function can't have access too. So, it works more like a simple function, not a member function</p>
<p></p>
<div class="alert alert-primary"><p><strong>Note</strong>, that just like other functions, extension functions <strong>can take arguments and return a value</strong> of any type including the same type as the receiver type.</p></div>
<p></p>
<p>So the issue is solved: Kotlin developers can add any functions to any classes they want.</p>
<p>We also need to mention that extension functions are used even in Kotlin <a class="theory-lookup not-relevant" href="/learn/step/6621" target="_blank" title="In Kotlin, a standard library is a fundamental part of the Kotlin programming language that is included with the language and provides essential functionality for working with the language. | It offers a robust set of tools to handle various programming tasks efficiently, and it is designed to work seamlessly with Kotlin's language features. The standard library includes functions, classes, and methods that provide pre-built functionality, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. Examples of functionalities provided by the Kotlin standard library include handling complex math calculations like the sine and cosine of an angle. Standard libraries can be categorized into those that are included with the language and provide essential functionality, and third-party libraries that offer specialized or advanced features.">standard library</a>. For example, if you look at the <code class="language-kotlin">String</code> class definition, you will see only necessary member functions. Other functions such as <code class="language-kotlin">.first()</code> and <code class="language-kotlin">.toUpperCase()</code> are actually extension functions needed just to simplify the code of the class.</p>
<h5 id="extension-function-vs-member-function">Extension function vs member function</h5>
<p>Let's assume we have the following class:</p>
<pre><code class="language-kotlin">class A {
    fun member() = println("hi from member")
}

fun A.extension() = println("hi from extension")</code></pre>
<p>Both functions can be called in the same way: <code class="language-kotlin">A().member()</code> and <code class="language-kotlin">A().extension()</code>. So we actually can't be sure if it's a member or an extension function just by looking at its calling line. We need to check the implementation.</p>
<p>And what if a developer tries to add an already existing function to a class? The answer is a bit complex here because there can be several different cases.</p>
<p>If we try to define another <code class="language-kotlin">fun A.extension()</code>, the code won't compile. You cannot define two functions with the same signature, as always.</p>
<p>If we add <code class="language-kotlin">fun A.member() = println("bye from not member")</code>, the code will compile but calling <code class="language-kotlin">A().member()</code> will give us <code class="language-kotlin">"hi from member"</code>.</p>
<p>So <strong>member functions always win</strong>. It helps when somebody wants to change the object behavior intentionally or unintentionally.</p>
<p>If you want to give an extension function the name that already exists, you must change the signature of the function, for example, change its arguments. It won't break the already existing code.</p>
<h5 id="idiom">Idiom</h5>
<p>The extension function is an idiomatic way to add some functionality to an existing class. It is simple to use and shows that your new function is closely related to the class. So use it, with community approval! This idiom is documented on <a href="https://kotlinlang.org/docs/idioms.html#extension-functions" rel="noopener noreferrer nofollow" target="_blank">kotlinlang.org</a>.</p>
<pre><code class="language-kotlin">fun String.spaceToCamelCase() { ... }

"Convert this to camelcase".spaceToCamelCase()</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>The extension function is a useful instrument, that can help you work with the existing class. Sometimes you can't change this class. Other times you need to add some functionality and don't want to store it in your class, because it takes up a lot of space. The extension function is a good solution for all of this. Good luck with tasks!</p>
</div>