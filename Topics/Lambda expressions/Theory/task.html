<div class="step-text">
<p>We already know how to declare functions with fixed names. Now, let's find out the last first-class-citizen feature: the opportunity to create a function at runtime and without a predefined name. That's lambda! Lambda is one of the most important features and is used profusely in modern programming.</p>
<h5 id="functions-without-names">Functions without names</h5>
<p>To create a Kotlin function that isn't bound to its name, you can use either an <strong>anonymous</strong> function or a <strong><a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, a lambda expression is a function without a name, allowing you to use and pass around code as data. | They are often more readable than function references and force developers to break down a program into smaller functions with clear responsibilities. For instance, you can call a function directly or by passing its value using a function reference. Lambda expressions have a reasonable type, just like top-level functions. If a lambda expression has no arguments, you don't need to include the arrow symbol. You might wonder how to use a function without a known name.">lambda expression</a></strong>:</p>
<ul><li><p><code class="language-kotlin">fun(arguments): ReturnType { body }</code> – this is commonly called an "anonymous function".</p></li><li><p><code class="language-kotlin">{ arguments -&gt; body }</code> – this is commonly called a "lambda expression".</p></li></ul>
<p>To better understand it, take a look at the example below. Here, two functions are declared: they are declared in different ways, but they do the same thing:</p>
<pre><code class="language-kotlin">fun(a: Int, b: Int): Int {
    return a * b
} // normal function but no name 

{ a: Int, b: Int -&gt; a * b } // we shifted the parameter or argument in the curly braces</code></pre>
<p>As you see, they compute the multiplication of two numbers.</p>
<p>Both these functions have a reasonable type: <code class="language-kotlin">(Int, Int) -&gt; Int</code>. So, types work here just the way they do for top-level functions discussed in previous topics.</p>
<p>Note that if you want to declare a <strong>lambda without arguments</strong>, you do not need to write the "arrow symbols". A lambda without argument definition looks like this: <code class="language-kotlin">{ body }</code>.</p>
<p>You may ask: how can we use a function without a known name? The answer is: there are several options.</p>
<p>For example, you can assign the function to a variable and then invoke it by invoking the variable:</p>
<pre><code class="language-kotlin">val mul1 = fun(a: Int, b: Int): Int {
    return a * b
}

val mul2 = { a: Int, b: Int -&gt; a * b }

println(mul1(2, 3))  // prints "6"
println(mul2(2, 3))  // prints "6" too</code></pre>
<p>Also, you can pass such a function as an argument or return such a function from another function.</p>
<p>Finally, you can place parentheses with desired arguments right after the function definition to invoke it in place. However, that doesn't make much sense. So, mostly the first three described options are used.</p>
<p>The process of creating these two functions is quite similar, but lambdas have a more concise and convenient syntax. Therefore, lambdas are almost always used to create a function at runtime in real life. Moreover, there are programmers who don't stick to Kotlin official naming rules and can say "an <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, an anonymous function is a function that is declared without a name and does not have its own identity. | It is created at runtime and can be passed around like a variable. Anonymous functions are useful for creating function objects, implementing event listeners, managing asynchronous tasks, and working with collections. They can be defined in line or through well-named functions, which improves code readability. Anonymous functions can be created using either an anonymous function or a lambda expression. They are first-class citizens in Kotlin, meaning they can be used as arguments, returned by functions, and assigned to variables.">anonymous function</a>" instead of "a lambda". Despite the fact that everybody understands them, we suggest that you use the proper naming.</p>
<p>For the same reason of convenience, now we will talk only about lambdas.</p>
<h5 id="lambdas-and-syntactic-sugar">Lambdas and syntactic sugar</h5>
<p>There are ways to make code more readable for human beings without changing the code logic. If there is such a way in a programming language and it relates to <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, a syntax refers to the set of rules and conventions that dictate how a program should be written in the language. | It includes the structure of statements, expressions, and keywords, as well as the use of indentation, whitespace, and comments. An expression, for example, is a type of syntax that evaluates to a single value, such as a literal value, variable, function call, or a combination of these elements using operators. Understanding the syntax of Kotlin is essential for writing clear, maintainable, and error-free code.">syntax</a>, we call it <strong><a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, syntactic sugar refers to the language's syntax that makes the code more readable and concise without changing its meaning or behavior. | One example of syntactic sugar in Kotlin is scope functions, such as `let`, `run`, `with`, `apply`, and `also`. These functions do not perform any specific action but organize the code and execute certain operations in the object context. They create a temporary scope for the object and invoke code from a lambda expression. Scope functions allow for more concise and expressive code by enabling communication with the object using the keywords `it` or `this` within the lambda. This syntax can make the code look similar to a domain-specific language (DSL), which can improve code readability and maintainability. While using scope functions can make the code more concise and readable, it is essential to use them judiciously, as excessive use can make the code harder to understand and maintain.">syntactic sugar</a></strong>. Kotlin promotes Functional Programming so there is syntactic sugar for it.</p>
<p>Let's recall this example of passing a function as an argument:</p>
<pre><code class="language-kotlin">fun isNotDot(c: Char): Boolean = c != '.'
val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter(::isNotDot) 
println(textWithoutDots) // I don't know what to say</code></pre>
<p>Simply put, we have created the function <code class="language-kotlin">isNotDot</code>, which returns <code class="language-kotlin">Boolean</code> and then uses <code class="language-kotlin">originalText.filter</code>, which will iterate over every char in the string, apply the <code class="language-kotlin">isNotDot</code> function, and then return a string without any dots. The filter excludes any char in the string that returns false.</p>
<p>Just in case, there is a specific topic for <a href="https://hyperskill.org/learn/step/22367" rel="noopener noreferrer nofollow" target="_blank">filtering elements in collection</a>.</p>
<p>Now, let's rewrite it to pass a lambda:</p>
<pre><code class="language-kotlin">val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter({ c: Char -&gt; c != '.' })
println(textWithoutDots) // I don't know what to say</code></pre>
<p>It works! First of all, we don't need to specify a function and then take reference from it.</p>
<p>Kotlin infers types of many objects, and here specifying the <code class="language-kotlin">c</code> type isn't necessary:</p>
<pre><code class="language-kotlin">originalText.filter({ c -&gt; c != '.' })</code></pre>
<p>Second, there are situations when the lambda is passed as the last argument. In such a case, Kotlin provides a way to eliminate bracket sequences ({ }) and write the lambda outside the parentheses:</p>
<pre><code class="language-kotlin">originalText.filter() { c -&gt; c != '.' }</code></pre>
<p>If the parentheses are left empty after that operation, you can remove them:</p>
<pre><code class="language-kotlin">originalText.filter { c -&gt; c != '.' }
</code></pre>
<p>Please note that sometimes function reference is more readable than a lambda, and there is no right answer which one is preferable. However, if the code is quite complex, instead of copy-pasting some lambda, it may be better to use function reference for easier maintenance and reusability.  </p>
<h5 id="implicit-name-of-a-single-parameter-it">Implicit name of a single parameter: it </h5>
<p>Finally, when there is a single parameter in a lambda, there is an opportunity to skip it. The parameter is available under the <code class="language-kotlin">it</code> name. The type of <code class="language-kotlin">it</code> is inferred from the type of the argument being passed to the lambda. The final version of the code that removes dots is this:</p>
<pre><code class="language-kotlin">val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter { it != '.' }</code></pre>
<p>Pretty impressive, huh?</p>
<p>Returning from a lambda expression in Kotlin is achieved using <code class="language-kotlin">return@label</code>, where <code class="language-kotlin">label</code> is a tag, usually matching the name of the <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, a higher-order function is a function that can take one or more functions as parameters or return a function as its result. | This feature allows for more modular, reusable, and maintainable code, as it promotes functional programming patterns and prevents issues with shared state in concurrent environments. Higher-order functions can be used to simplify complex situations and enhance code organization through functional decomposition. They are an essential part of Kotlin's support for functional programming, along with other features like lambda expressions, anonymous functions, and monads.">higher-order function</a> in the context of which the lambda was called. For example, when using <code class="language-kotlin">someLambda</code> as a lambda expression in a higher-order function, the return from the lambda would look like <code class="language-kotlin">return@someLambda</code>.</p>
<p style="text-align: start;">This is particularly useful in cases where the lambda is used in functions such as <code class="language-kotlin">forEach</code>, <code class="language-kotlin">map</code>, <code class="language-kotlin">let</code>, and so on. Returning with <code class="language-kotlin">return@label</code> allows for exiting the lambda expression without interrupting the execution of the outer function.</p>
<p style="text-align: start;">Here is an example of using <code class="language-kotlin">return@label</code> in Kotlin:</p>
<pre><code class="language-kotlin">listOf(1, 2, 3, 4).forEach { 
    if (it == 3) return@forEach  // Skipping number 3
    println(it)
}
println("End")</code></pre>
<p>In this example, when <code class="language-kotlin">it</code> equals 3, the lambda expression is interrupted and continues with the next iteration of the <code class="language-kotlin">forEach</code> loop. <code class="language-kotlin">println("End")</code> will execute after the loop completes.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Lambda expressions are one of the most important and powerful features in Kotlin and in <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, functional programming is a style of programming that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. | It emphasizes immutability, pure functions, and higher-order functions. The Kotlin standard library provides many functions for collections, such as `filter`, `map`, and `reduce`, which are commonly used in functional programming. These functions allow you to process and transform data in a declarative way, without changing the original data.">functional programming</a>. In this topic, we've learned what anonymous functions and lambdas are. Lambdas help us create functions at runtime. This is convenient when calling functions from Kotlin <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, a standard library is a fundamental part of the Kotlin programming language that is included with the language and provides essential functionality for working with the language. | It offers a robust set of tools to handle various programming tasks efficiently, and it is designed to work seamlessly with Kotlin's language features. The standard library includes functions, classes, and methods that provide pre-built functionality, which can be invoked or used in your code, saving you the time and effort of writing these functionalities from scratch. Examples of functionalities provided by the Kotlin standard library include handling complex math calculations like the sine and cosine of an angle. Standard libraries can be categorized into those that are included with the language and provide essential functionality, and third-party libraries that offer specialized or advanced features.">standard library</a> (e.g., those processing data), as it helps reduce code length. Finally, we've hopefully convinced you that functions are <a class="theory-lookup not-relevant" href="/learn/step/30148" target="_blank" title="In Kotlin, a first-class citizen refers to a language construct that is treated as a full-fledged value with equal status. | This includes variables, functions, and objects. They can be passed as arguments to functions, returned as values from functions, assigned to variables, and stored in data structures like arrays and maps. This treatment allows for greater flexibility and expressiveness in the language, making it easier to write concise and expressive code. For example, functions in Kotlin are first-class citizens, meaning they can be assigned to variables, passed as arguments to other functions, and returned as values from functions.">first-class citizens</a> in the Kotlin language.</p>
</div>